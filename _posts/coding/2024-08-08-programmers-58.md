---
layout: single
title: "프로그래머스 - [1차] 비밀지도"
categories: 
  - coding
tag:
  - [python, coding, grammar]
--- 
[문제링크](https://school.programmers.co.kr/learn/courses/30/lessons/17681)  

## 📌 [1차] 비밀지도

#### 📖문제 설명 :  
네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.

1. 지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 "공백"(" ") 또는 "벽"("#") 두 종류로 이루어져 있다.
2. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 "지도 1"과 "지도 2"라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.
3. "지도 1"과 "지도 2"는 각각 정수 배열로 암호화되어 있다.
4. 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.

![image](https://github.com/user-attachments/assets/832c2e8a-f216-459b-a17a-8ba8ddfbfb20)

네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.

#### 📖 입력 형식 :  
입력으로 지도의 한 변 크기 n 과 2개의 정수 배열 arr1, arr2가 들어온다.

- 1 ≦ n ≦ 16
- arr1, arr2는 길이 n인 정수 배열로 주어진다.
- 정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다.

#### 📖 입출력 예 : 

|n|arr1|arr2|result|
|---|---|---|----|
|5|	[9, 20, 28, 18, 11]|[30, 1, 21, 17, 28]|["#####","# # #", "### #", "# ##", "#####"]|
|6|[46, 33, 33 ,22, 31, 50]|[27 ,56, 19, 14, 14, 10]|["######", "### #", "## ##", " #### ", " #####", "### # "]|

#### 😅 오류 코드  
```python
def solution(n, arr1, arr2):
    answer = []
    a = [[0] * n for i in range(n)] # 0으로 초기화된 2차원 배열 생성

    for i in range(len(a)):
        for j in range(len(a[i])):
            a = (bin(arr1[i])[2:]).zfill(n)
            answer.append(a)
        # print(list((bin(arr1[i])[2:]).zfill(n))) # .zfill() : 문자 왼쪽애서 원하는 만큼 0으로 채워줌
    print(a)
    return answer
# 01011
['01001', '01001', '01001', '01001', '01001', '10100', '11100', '10010', '01011']
```
이중 for문을 사용해 각각의 원소에 접근하여 이진수로 바꾸어준 후, or연산을 해 1은 #으로 0은 공백으로 비워주려고 했다. 
이렇게 코드를짜며, print를 해보며 테스트하다보니 정답값과 확실히 다른 값이 나왔다. 어떻게 할 지 고민하다 다른사람에게 도움을 요청하기로 했다. 

#### ✏️ 정답 코드  
```python
def solution(n, arr1, arr2):
    answer = []
    new_map = ''
    for i in range(n):
        # or연산 후 2진수로 바꿔주고, zfill()함수를 사용해 앞자리를 0으로 채워준다.
        # 변환해준 후, replace()함수를 사용해 1은 #으로 0은 공백으로 교체해준다. 
        new_map = format(arr1[i] | arr2[i], 'b').zfill(n).replace('1', '#' ).replace('0', ' ') 
        answer.append(new_map)
    
    return answer
```
2장의 지도를 겹쳐 2개다 공백일 경우 공백으로 처리해주어야 하므로, or연산을 하면 비밀지도를 만들 수 있다. 
arr1과 arr2를 이진수로 바꾸지않고 바로 or연산을 해준 뒤 format()을 사용해 2진수로 바꿔줄 수 있다. 
format()을 사용한 이유는 bin()함수는 2진수로 변환할 때 '0b'라는 2진수 표시문자가 함께 출력되는데 이 문자 없이 2진수 값만 표시할 수 있기 때문이다. 
이진수로 변환해준 후, zfill()함수로 앞자리가 0인 경우 공백으로 채워지는 문제점이 있는데, 그 빈자리를 0으로 채워주고 
1은 #으로 0은 공백으로 변환해 반환해준다. 

#### ✨ 느낀점 
- 숫자를 2진수로 바꾸지않고 or연산을 해도 계산이 된다는 것을 알게되었고, bin()함수를 사용해 2진수로 바꾸고 슬라이싱을 하여 표시문자를 없앴는데,
  format()함수를 사용하면 슬라이싱 없이 표시문자를 표시하지 않을 수 있다는 것을 알게되었다.
  zfill()함수에 대해서도 알 수 있는 기회였어서 좋았다. 수학쪽으로 문제가 나오면 좀 약한 거 같아 수학을 사용하는 문제를 많이 풀어봐야할 거 같다.
  이런 비슷한 문제가 나오면 그땐, 혼자 풀 수 있도록 노력해야겠다. 

  
